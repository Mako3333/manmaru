# TypeScriptリンターエラー対応ガイドライン

## 基本方針

1. **対症療法ではなく根本解決を目指す**：エラーを単に抑制するのではなく、根本的な問題を特定して解決します。
2. **型安全性の確保**：TypeScriptの型システムを最大限に活用し、実行時エラーを防ぎます。
3. **コードの堅牢性向上**：より安全で予測可能なコードを目指します。

## 主要なエラーパターンと解決策

### 1. 型の不一致エラー

**エラー例**：`型 '200' には型 'ApiResponseMeta' と共通のプロパティがありません`

**原因**：関数が特定の型を期待しているのに、異なる型の値を渡している。

**解決策**：
- 関数のシグネチャを確認し、期待される型を把握する
- 適切な型の値を渡す

```typescript
// ❌ 不適切
return createSuccessResponse(data, 200);  // 数値を渡している

// ✅ 適切
return createSuccessResponse(data, { processingTimeMs: 0 });  // 正しいオブジェクト型
```

### 2. nullまたはundefinedの可能性がある値へのアクセス

**エラー例**：`オブジェクトは 'undefined' である可能性があります`

**原因**：nullまたはundefinedの可能性がある値のプロパティにアクセスしている。

**解決策**：
- デフォルト値を提供する（`||` または `??` 演算子を使用）
- オプショナルチェイニング（`?.`）を使用する
- 事前に値の存在確認を行う

```typescript
// ❌ 不適切
const avg = nutrientSums[key] / nutrientCounts[key];  // どちらもundefinedの可能性がある

// ✅ 適切 - デフォルト値を提供
const count = nutrientCounts[key] || 0;
if (count > 0) {
    const sum = nutrientSums[key] || 0;
    const avg = sum / count;
    // ...
}

// ✅ 適切 - オプショナルチェイニングと条件チェック
if (nutrientCounts?.[key] > 0) {
    const avg = (nutrientSums?.[key] ?? 0) / nutrientCounts[key];
    // ...
}
```

### 3. any型の使用

**エラー例**：`Unexpected any. Specify a different type.`

**原因**：明示的なany型の使用または型推論が不十分な場合。

**解決策**：
- 適切な型定義を行う
- ジェネリック型を活用する
- カスタム型やインターフェースを作成する

```typescript
// ❌ 不適切
function processData(data: any) { ... }

// ✅ 適切
interface DataItem {
    id: string;
    value: number;
}
function processData(data: DataItem[]) { ... }
```

## ベストプラクティス

1. **早期検証**：データの操作前に存在チェックや型チェックを行う
2. **デフォルト値の活用**：undefined/nullの可能性がある値にはデフォルト値を設定する
3. **型ガード**：適切な型ガードを使用して型の絞り込みを行う
4. **ジェネリック型の活用**：汎用的な関数や構造体には適切なジェネリック型を使用する
5. **インターフェースの明確化**：関数やコンポーネントのインターフェースを明確に定義する

## エラー解決の手順

1. エラーメッセージを注意深く読み、問題の性質を理解する
2. 関連するコードの文脈と型の定義を確認する
3. 根本的な原因を特定する（単に症状を抑制するのではなく）
4. 適切な解決策を適用し、コードの安全性と読みやすさを向上させる
5. 変更後に再度リンターを実行して、すべてのエラーが解決されたことを確認する

## 利点

- **実行時エラーの削減**：型の不一致や存在しないプロパティへのアクセスによるエラーを事前に防ぐ
- **コードの自己文書化**：適切な型定義はコードの理解を助ける
- **リファクタリングの安全性向上**：型チェックにより変更の影響範囲を把握しやすくなる
- **開発体験の向上**：エディタの自動補完や型ヒントの精度が向上する

