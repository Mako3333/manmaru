# 栄養計算アルゴリズム

## 概要

manmaruアプリケーションにおける栄養計算アルゴリズムは、ユーザーが記録した食事（写真またはテキスト入力）から栄養素の摂取量を推定し、個々の妊婦さんにとっての栄養充足状況を評価するための中核機能です。Phase 2.1の実装により、このアルゴリズムは大幅に改善され、特に以下の点で進化しました：

1. データ構造の標準化：`StandardizedMealNutrition`型への統一
2. AI推定値の直接活用と食品マッチングの組み合わせによるハイブリッドアプローチ
3. 食事全体と個別食品の両方のレベルでの栄養素管理の実現

このドキュメントでは、現在の栄養計算アルゴリズムの仕組み、使用されるデータ構造、計算プロセス、および既知の制約について説明します。

## データ構造

### 標準化された栄養データ型：`StandardizedMealNutrition`

栄養計算のコア部分では、`StandardizedMealNutrition`型（`src/types/nutrition.ts`で定義）を採用しています。この型は以下の特徴を持ちます：

```typescript
interface StandardizedMealNutrition {
  totalCalories: number;                 // 総カロリー (kcal)
  totalNutrients: Nutrient[];            // 全栄養素のリスト
  foodItems: FoodItem[];                 // 個別食品アイテムのリスト
  reliability?: { confidence: number };  // 栄養計算の信頼性スコア
  pregnancySpecific?: {                 // 妊娠特有の栄養充足率情報
    nutrientSufficiency: {
      [key: string]: { percentage: number, isRecommended: boolean }
    }
  };
}

// 個別の栄養素データ
interface Nutrient {
  name: string;   // 栄養素名（例: "たんぱく質", "鉄分"）
  value: number;  // 数値
  unit: string;   // 単位（例: "g", "mg", "μg"）
}

// 個別の食品アイテム
interface FoodItem {
  id: string;
  name: string;           // 食品名
  amount: number;         // 量
  unit: string;           // 単位（例: "g", "個", "人前"）
  nutrition: FoodItemNutrition; // 食品単体の栄養情報
}

// 食品単体の栄養情報
interface FoodItemNutrition {
  calories: number;       // カロリー
  nutrients: Nutrient[];  // 栄養素リスト
  servingSize?: {         // 提供量情報
    value: number;
    unit: string;
  };
}
```

この構造により、食事全体の総栄養素と各食品アイテムの詳細な栄養情報を同時に管理できるようになりました。フェーズ2実装では、アプリケーション内の食事記録フロー全体で`StandardizedMealNutrition`型を一貫して使用するように修正されました。

## 栄養計算アルゴリズムのフロー

現在の食品特定、栄養計算、データ保存のフローは、入力方法（写真またはテキスト）によって異なります。

### 写真入力の場合

1.  **食品特定段階:**
    *   ユーザーが食事の写真をアップロードします。
    *   フロントエンドは `/api/v2/meal/analyze` エンドポイントを呼び出します。
    *   バックエンド (`GeminiService.analyzeMealImage`) はAI（Gemini Vision）に画像を送信します。
    *   AIは写真に含まれる食品を特定し、食品リスト (`foods: [{ foodName, quantityText, confidence }]`) とAI推定栄養価 (`aiEstimatedNutrition` - 参考値) を返却します。
    *   **APIはこの時点では栄養計算を行いません。**
    *   APIは食品リストとAI推定栄養価をフロントエンドに返します。

2.  **編集段階:**
    *   フロントエンドは受け取った食品リストを編集画面 (`RecognitionEditor`) に表示します。
    *   ユーザーは必要に応じて食品リストを編集（追加、削除、修正）します。

3.  **栄養計算・保存段階:**
    *   ユーザーが「保存」ボタンをクリックします。
    *   フロントエンドは**編集後の食品リスト** (`editedFoodItems`) と、参考情報として**AI推定栄養価** (`aiEstimatedNutrition`) を `/api/meals` (POST) エンドポイントに送信します。
    *   バックエンド (`MealService.saveMealWithNutrition`) は、受け取った `editedFoodItems` を `NutritionService.calculateNutritionFromNameQuantities` に渡します。
    *   `NutritionService` は各食品について食品データベース（FOODEX）とのマッチングを行い、量単位変換を適用し、**栄養計算を実行**します。
    *   計算結果として `StandardizedMealNutrition` オブジェクトが生成されます。
    *   バックエンドは生成された `StandardizedMealNutrition` データを `meals` テーブルの `nutrition_data` カラムにJSONB形式で保存します。

### テキスト入力の場合

1.  **食品特定・栄養計算段階:**
    *   ユーザーが食事内容をテキストで入力します。
    *   フロントエンドは `/api/v2/meal/text-analyze` エンドポイントに入力テキストを送信します。
    *   バックエンド (`GeminiService.analyzeMealText`) はAI（Gemini）にテキストを送信し、食品リスト (`foods`) とAI推定栄養価 (`aiEstimatedNutrition` - 参考値) を取得します。
    *   **続けて、同じAPIルート内で**、取得した食品リスト (`foods`) を `NutritionService.calculateNutritionFromNameQuantities` に渡します。
    *   `NutritionService` は食品DBとのマッチング、量単位変換、**栄養計算を実行**します。
    *   計算結果として `StandardizedMealNutrition` オブジェクトが生成されます。
    *   APIは計算された `StandardizedMealNutrition` データと、参考情報として `aiEstimatedNutrition` をフロントエンドに返します。

2.  **編集段階:**
    *   フロントエンドは受け取った食品リスト（および計算済み栄養価）を編集画面 (`RecognitionEditor`) に表示します。
    *   ユーザーは必要に応じて食品リストを編集します。

3.  **保存段階:**
    *   ユーザーが「保存」ボタンをクリックします。
    *   フロントエンドは**編集後の食品リスト**と、**テキスト解析時に計算済みの栄養データ** (`StandardizedMealNutrition`) を `/api/meals` (POST) エンドポイントに送信します。
    *   **注意:** 保存APIでは、テキスト入力の場合は原則としてフロントエンドから送られてきた計算済み栄養データをそのまま利用します。ただし、将来的に編集内容に応じて再計算するロジックが追加される可能性はあります。
    *   バックエンドは受け取った `StandardizedMealNutrition` データを `meals` テーブルの `nutrition_data` カラムにJSONB形式で保存します。

### レシピURL入力の場合 (レシピクリップ機能)

1.  **レシピ解析・栄養計算段階:**
    *   ユーザーがレシピページのURLを入力します。
    *   フロントエンドは `/api/v2/recipe/parse` エンドポイントにURLを送信します。
    *   バックエンドはURLを解析します。対応サイト（クックパッド等）であれば専用パーサーを、それ以外や失敗時はAI (Gemini) を使用してHTMLからレシピ情報（タイトル、材料リスト、**人数 `servingsNum`** 等）を抽出します。
    *   抽出した材料リストを `NutritionService.calculateNutritionFromNameQuantities` に渡して**栄養計算を実行**します。
    *   計算結果として `StandardizedMealNutrition` オブジェクトが生成されます。**注意: ここで計算される栄養価は、レシピ全体の合計値です。**
    *   APIは解析されたレシピ情報（**人数 `servingsNum` を含む**）と計算された `StandardizedMealNutrition` データ（**合計値**）をフロントエンドに返します。

2.  **クリップ・保存段階:**
    *   フロントエンドは受け取ったレシピ情報と栄養データを表示し、編集可能にします（人数も `servingsNum` から初期設定）。
    *   ユーザーが「レシピを保存」ボタンをクリックした場合、フロントエンドは編集後のレシピ情報（タイトル、URL、材料、**人数** (ユーザーが変更した可能性あり)、**レシピ全体の合計栄養価** (再計算は行わない場合が多い)、その他フラグ）を `/api/recipes/save` (POST) に**フラットな構造**で送信します。
    *   `/api/recipes/save` は、受け取ったデータを `clipped_recipes` テーブルに保存します。
        *   `nutrition_per_serving` カラムには、送信された**レシピ全体の合計栄養価**が保存されます。
        *   `servings` カラムには、送信された**レシピの元の人数** (例: 4) が保存されます。

### 食事記録追加の場合 (`/api/meals/from-recipe` POST)

1.  **データ取得:** リクエストボディから `recipe_id`, `meal_type`, `portion_size` (食べた割合), `meal_date` を受け取ります。
2.  **レシピ情報取得:** `recipe_id` を使って `clipped_recipes` テーブルからレシピ情報を取得します。
    *   `nutrition_per_serving` カラムから **レシピ全体の合計栄養価** を取得します。
    *   `servings` カラムから **レシピの元の人数** を取得します。
3.  **1人前計算:** 「レシピ全体の合計栄養価」を「レシピの元の人数」で割り、**1人前あたりの栄養価**を計算します。
4.  **摂取量計算:** 「1人前あたりの栄養価」に `portion_size` (食べた割合) を掛けて、**実際に摂取した栄養価**を計算します。
5.  **保存:** 計算された「実際に摂取した栄養価」を `meals` テーブルの `nutrition_data` カラムに、`portion_size` を `servings` カラムに保存します。

---

### （共通）栄養計算の詳細 (`NutritionService.calculateNutritionFromNameQuantities`)

栄養計算サービスは、食品リスト（名前と量のペア）を受け取ると以下の処理を行います：

1.  各食品名に対して、食品データベース（FOODEX）とのマッチングを試行します。
    *   前処理（料理名分解、同義語対応など）が適用される場合があります。
2.  マッチングした食品DBの情報と、入力された量（単位変換を含む）に基づき、各食品の栄養価（カロリー、各種栄養素）を計算します。
3.  **DBにマッチしなかった食品の扱いは、現状では栄養計算に含まれません。** (AI推定値のフォールバック利用はMVP後の課題)
4.  計算された個々の食品の栄養情報を `foodItems` 配列に格納します。
5.  全食品の栄養素を合計して、食事全体の `totalNutrients` と `totalCalories` を算出します。
6.  マッチングの確度などを考慮して、計算結果の信頼性スコア (`reliability.confidence`) を設定します。
7.  最終的な `StandardizedMealNutrition` オブジェクトを生成して返却します。

### （共通）データ保存の詳細 (`MealService.saveMealWithNutrition`)

食事保存サービスは、`StandardizedMealNutrition` データを受け取り、`meals` テーブルの `nutrition_data` カラムにJSONB形式で保存します。フェーズ2の改善により、`meal_nutrients` テーブルへの書き込みは廃止されました。

## 栄養計算の精度と妊婦向け栄養管理

manmaruアプリケーションの特性上、栄養計算は一般的な栄養素（カロリー、タンパク質、脂質、炭水化物など）に加え、妊婦に特に重要な栄養素（鉄、葉酸、カルシウム、ビタミンDなど）を重点的に計算・表示します。

### 妊婦向け栄養管理の特別対応

1. **重点栄養素**:
   - 鉄分（非ヘム鉄・ヘム鉄）
   - 葉酸
   - カルシウム
   - ビタミンD
   - タンパク質
   - 食物繊維

2. **妊娠週数別の推奨摂取量**: 
   - 妊娠初期（〜15週）
   - 妊娠中期（16〜27週）
   - 妊娠後期（28週〜）

3. **表示方法**:
   - 摂取栄養素の充足率（%）を視覚的に表示
   - 不足している栄養素に警告表示

### AI直接推定値と食品マッチングの統合アプローチ

現在のシステムでは、AIによる栄養素推定値 (`aiEstimatedNutrition`) は、食事解析API (`/api/v2/meal/analyze`, `/api/v2/meal/text-analyze`) から**参考情報として**返却されます。

*   **現状の利用:** この値は直接的には最終的な栄養計算結果には使用されません。栄養計算は主に食品データベース（FOODEX）とのマッチングに基づいて行われます。
*   **将来的な活用:** MVPリリース後の改善タスクとして、食品データベースにマッチしなかった食品に対して、このAI推定値を**フォールバックとして利用**する機能の実装が計画されています (`docs/MVP/after/assignment.md` 参照)。これにより、記録される栄養情報の網羅性を向上させることが期待されます。

栄養計算の主体はあくまで `NutritionService` によるDBベースの計算であり、AI推定値の扱いは今後の改善課題です。

1. **食品DBマッチングの優先度向上**:
   - 食品名のマッチング精度向上のための前処理（料理名分解、同義語対応など）の強化
   - マッチングアルゴリズムの最適化（類似度計算の改善）

2. **信頼性スコアの改善**:
   - マッチング確度に基づく信頼性スコアの算出
   - ユーザーへの透明性向上のためのUI表示の改善

## フェーズ2実装による主な改善点

フェーズ2実装およびその後の修正により、以下の重要な改善が行われました：

1.  **画像解析と栄養計算の完全分離**: 画像入力フローにおいて、食品認識 (`/api/v2/meal/analyze`) と栄養計算・保存 (`/api/meals` POST) が明確に分離されました。
2.  **`StandardizedMealNutrition`型への一貫した移行**: 食事記録フロー全体で一貫して`StandardizedMealNutrition`型を使用し、API間でのデータ形式を統一しました。
3.  **AIプロンプトの最適化**: 画像解析AIプロンプトから栄養素推定の要求を削除し、食品特定に集中させ、AIの役割を明確化しました。
4.  **データ保存プロセスの簡素化**: `meal_nutrients`テーブルを廃止し、すべての栄養データを`meals.nutrition_data`カラムに`StandardizedMealNutrition`形式で集約しました。
5.  **型変換の削減と型安全性の向上**: 不要な型変換を削除し、データフローを簡素化。TypeScriptの型システムと実行時検証により、特にテキスト入力フローにおける安定性が向上しました。

これらの改善により、食事記録フローの信頼性と保守性が向上し、栄養計算結果の一貫性が強化されました。

## テキスト入力フローの最適化（フェーズ2.2）

フェーズ2.2では特にテキスト入力フローの安定化に注力しました：

1. **テキスト入力フローの詳細化**:
   ```
   ユーザーテキスト入力 → テキスト解析・栄養計算API (/api/v2/meal/text-analyze)
   → StandardizedMealNutrition取得 → フロントエンドで編集
   → 保存API (/api/meals POST) → DB保存
   ```

2. **厳密なデータ検証**:
   - フロントエンド: 入力データの空チェック、最小限の入力検証
   - API層: `StandardizedMealNutrition`形式の厳密な検証
   - サービス層: DB保存前の最終的なデータ整合性チェック

3. **エラーリカバリ戦略**:
   - 各層での詳細なエラーメッセージとユーザーフレンドリーな通知
   - エラー発生時のデータ保持と再試行機能
   - エラーログの拡充によるデバッグ容易性の向上

4. **型安全性の強化**:
   - TypeScriptの型システムを最大限活用
   - 実行時の型チェックと静的型チェックの組み合わせ
   - 想定外のデータ形式への堅牢な対応

これらのフェーズ2.2での最適化により、テキスト入力から栄養計算、DB保存までの一連のフローが安定し、`StandardizedMealNutrition`型を一貫して使用する体制が確立されました。

## 今後の課題

現在の栄養計算アルゴリズムには以下の制約があります：

1. **食品認識の精度**: AIによる食品認識は、特に複雑な料理や複数の食品が混在する状況で誤認識が発生することがあります。

2. **食品DBのカバレッジ**: 現在の食品データベースでは、日本の一般的な料理の一部がカバーされていないことがあります。特に、地域特有の料理や特定の調理法については対応が十分でない場合があります。

3. **量の換算精度**: 「一人前」や「お茶碗一杯」などの曖昧な量表現を正確なグラム数に変換する際の精度に課題があります。

4. **妊婦特有の栄養充足率計算**: 現在の`pregnancySpecific`フィールドの計算ロジックは未最適化であり、完全に正確な充足率を表現できていない可能性があります。

### 今後の改善方針

1. **AIモデルの改善**:
   - より高精度な食品認識モデルの導入
   - 複合料理の構成食材推定の精度向上

2. **食品データベースの拡充**:
   - 日本の一般家庭料理のカバレッジ拡大
   - ユーザーフィードバックに基づくデータ補完

3. **量換算アルゴリズムの精緻化**:
   - より正確な標準提供量データベースの構築
   - 地域・料理ジャンル別の量換算係数の導入

4. **妊婦特有の栄養管理機能強化**:
   - 妊娠週数に応じたより詳細な栄養推奨値の適用
   - 個人差（体重、活動量等）を考慮した推奨量の調整
   - 栄養バランスを考慮した食事アドバイス機能

5. **データフローのさらなる最適化**:
   - 残りのアプリ機能における`StandardizedMealNutrition`型への完全移行
   - 栄養管理ダッシュボードでのデータ表示とフィルタリングの改善
   - レガシーコードと変換関数の整理・削除

