# manmaruプロジェクト栄養素計算システム - 課題と改善点の詳細記録

## 1. 概要

**プロジェクト名**: manmaru（妊婦向け栄養管理アプリ）  
**主要課題**: 栄養素計算精度の低さと冗長なロジック  
**プラットフォーム**: Next.js based PWA

manmaruは妊婦の食事から栄養素を計算し、推奨摂取量との比較や管理を行うアプリケーションです。食事記録の方法として「画像入力」「テキスト入力」「レシピクリップ」の3経路があります。いずれの経路でも栄養素計算の精度に課題があり、特に低確信度データの採用や冗長な正規化ロジックが問題となっています。

## 2. データフロー詳細

### 2.1 ユーザー入力から栄養データ保存までのフロー

```mermaid
flowchart TD
    subgraph "ユーザー入力経路"
        A1[食事写真撮影] --> B1[/api/analyze-image]
        A2[テキスト入力] --> B2[/api/analyze-text-input]
        A3[レシピURL入力] --> B3[/api/recipes/parse-url]
    end

    subgraph "AI処理層"
        B1 --> C1[AIService.analyzeMeal]
        B2 --> C2[AIService.analyzeTextInput]
        B3 --> C3[RecipeService.parseRecipeFromUrl]
        C3 --> C3a[/api/recipes/calculate-nutrients]
        C3a --> C2
    end

    subgraph "栄養計算層"
        C1 --> D1[AI モデル処理]
        C2 --> D2[AI モデル処理]
        D1 --> E1[parseAiResponse]
        D2 --> E1
        E1 --> F1[enhanceResultWithDatabase]
        F1 --> G1{SupabaseDB利用可?}
        G1 -->|Yes| H1[SupabaseFoodDatabase.calculateNutrition]
        G1 -->|No| H2[NutritionDatabase.calculateNutrition]
    end

    subgraph "データ保存層"
        H1 --> I1[RecognitionEditor]
        H2 --> I1
        I1 --> K1[/api/meals]
        K1 --> L1[MealService.saveMealWithNutrition]
        L1 --> M1[meals テーブル]
        L1 --> M2[meal_nutrients テーブル]
    end
```

### 2.2 関連コンポーネントとファイルパス

1. **API エンドポイント**:
   - `src/app/api/analyze-image/route.ts` - 画像解析API
   - `src/app/api/analyze-text-input/route.ts` - テキスト入力解析API
   - `src/app/api/recipes/parse-url/route.ts` - レシピURL解析API
   - `src/app/api/recipes/calculate-nutrients/route.ts` - 栄養素計算API
   - `src/app/api/meals/route.ts` - 食事データ保存API

2. **サービスクラス**:
   - `src/lib/ai/ai-service.ts` - AI処理統合クラス
   - `src/lib/services/recipe-service.ts` - レシピ処理サービス
   - `src/lib/services/meal-service.ts` - 食事データ処理サービス

3. **栄養計算ロジック**:
   - `src/lib/nutrition/supabase-db.ts` - Supabase食品DB接続
   - `src/lib/nutrition/database.ts` - ローカル食品DB (フォールバック)
   - `src/lib/nutrition/calculator.ts` - 栄養素計算ユーティリティ

4. **フロントエンドコンポーネント**:
   - `src/components/meals/recognition-editor.tsx` - 食品認識編集UI
   - `src/components/meals/meal-photo-input.tsx` - 写真入力コンポーネント

5. **型定義ファイル**:
   - `src/types/nutrition.ts` - 栄養関連の型定義
   - `src/types/meal.ts` - 食事関連の型定義

6. **AIプロンプト**:
   - `src/lib/ai/prompts/templates/food-analysis/v1.ts` - 食品分析プロンプト
   - `src/lib/ai/model-factory.ts` - AIモデル生成ファクトリー

## 3. 主要な問題点とその所在

### 3.1 低確信度データの採用問題

**問題**: 極めて低い確信度スコア(0.25)でも食品マッチングを採用し、警告なく保存している

**該当ファイル**: 
- `src/lib/nutrition/supabase-db.ts`: 266行目付近
```typescript
if (fuzzyResults.length > 0 && fuzzyResults[0].similarity >= 0.25) { // 閾値を0.3から0.25に下げる
    const bestMatch = fuzzyResults[0];
    const dbFood = bestMatch.food;
    const similarity = bestMatch.similarity;
    // ...この低い類似度でもデータを採用
}
```

- `src/components/meals/recognition-editor.tsx`: 全体
  - 低確信度に関するユーザーへの警告・インジケーターが不十分

**影響**: 
- 「竹輪」を検索した際に「ちくわぶ」など類似度の低い（0.25～0.3程度）別食品とマッチする
- 誤マッチングにより栄養計算の誤差が大きくなる (カロリー値が期待値の1.3倍など)
- ユーザーが誤差に気づく機会がない

### 3.2 冗長で複雑な食品名マッチングロジック

**問題**: 複数のマッチング戦略と手動エイリアスマッピングが存在し、コードの冗長性と不整合を生んでいる

**該当ファイル**:
- `src/lib/nutrition/supabase-db.ts`: 204-221行目付近
```typescript
// 表記揺れ対応のマッピング
const aliasMap: Record<string, string> = {
    '竹輪': 'ちくわ',
    'ちくわ': 'ちくわ',
    'チクワ': 'ちくわ',
    '焼き竹輪': 'ちくわ',
    // 長いハードコードされたマッピングリスト...
};
```

- `src/lib/nutrition/supabase-db.ts`: 268-311行目（検索ロジック）
```typescript
// 複雑な検索プロセス
// まず完全一致 → エイリアス完全一致 → 部分一致 → エイリアス部分一致 → ファジー検索
```

**影響**:
- コードの保守性低下
- 食品データベースとコード内マッピングの同期が困難
- マッピング間の不整合
- タイプミスやエッジケースが見逃されやすい構造

### 3.3 複数の栄養計算クラスの重複と責任の曖昧さ

**問題**: 少なくとも4つの異なるクラスが栄養計算ロジックを持ち、一貫性がない

**該当ファイル**:
- `src/lib/ai/ai-service.ts`: 344-401行目 (`calculateNutritionUsingDatabase` メソッド)
- `src/lib/nutrition/supabase-db.ts`: 496-607行目 (`calculateNutrition` メソッド)
- `src/lib/nutrition/database.ts`: 未提供だが参照されている (`calculateNutrition` メソッド)
- `src/lib/nutrition/calculator.ts`: 14-63行目 (`calculateMealNutrition` メソッド)

**影響**:
- 入力経路によって栄養計算結果が異なる可能性
- コードの重複と一貫性欠如
- バグ修正が困難（1箇所の修正が他に波及しない）
- デバッグの複雑化

### 3.4 型定義の不整合と変換処理の散在

**問題**: 複数の栄養データ型が混在し、型変換が各所に散在している

**該当ファイル**:
- `src/types/nutrition.ts`: 全体 (複数の型定義)
  - `BasicNutritionData` インターフェース
  - `NutritionData` インターフェース
  - `StandardizedMealNutrition` インターフェース
  - その他多数の関連型
- `src/components/meals/recognition-editor.tsx`: 16-32行目
  - 独自の `Nutrition` インターフェースを定義
- `src/lib/ai/ai-service.ts`: 21-77行目
  - `FoodAnalysisResult` と `FoodAnalysisInput` インターフェース

**影響**:
- 同じデータを異なる型で処理する冗長な変換処理
- 型安全性の低下
- コード理解の困難さ
- バグの発生しやすさ

### 3.5 異常値の検出と補正の不十分さ

**問題**: 栄養素値の妥当性チェックと異常値補正が不十分または一貫性がない

**該当ファイル**:
- `src/lib/ai/ai-service.ts`: 569-611行目 (`validateNutritionValues` メソッド)
- 他のクラスでは同様の検証がない場合がある

**影響**:
- 極端に高い栄養素値がそのまま保存される可能性
- 食品によって許容範囲が異なる場合への対応不足
- 栄養計算の信頼性低下

### 3.6 ユーザーへのフィードバック不足

**問題**: 栄養計算の不確かさや低確信度マッチングに関するユーザーへの透明な情報提供が不足

**該当ファイル**:
- `src/components/meals/recognition-editor.tsx`: 200-278行目（UI部分）
  - 信頼度スコアの表示はあるが視覚的な警告や対応手段の提示がない
- `src/lib/ai/ai-service.ts`: 344-401行目 (`calculateNutritionUsingDatabase` メソッド)
  - 見つからない食品の情報はあるが、UI側でこれを効果的に表示していない

**影響**:
- ユーザーが栄養計算の不確かさを認識できない
- 誤った栄養データに基づいた意思決定
- 修正の機会がない

### 3.7 AI応答の解析と処理の複雑さ

**問題**: AIからの応答を解析して栄養データに変換するプロセスが複雑で、エラーハンドリングが不十分

**該当ファイル**:
- `src/lib/ai/response-parser.ts`: 全体
- `src/lib/ai/ai-service.ts`: 777-842行目 (`parseAiResponse` メソッド)

**影響**:
- 特定のAI応答パターンに依存したもろさ
- AI応答形式の変更に対する脆弱性
- エラー時の適切なフォールバック欠如

### 3.8 キャッシュ管理の冗長性と不整合

**問題**: 食品データのキャッシュ管理が複雑で、複数の場所に実装されている

**該当ファイル**:
- `src/lib/nutrition/supabase-db.ts`: 66-157行目 (キャッシュ管理)
- `src/app/api/calculate-nutrition/route.ts`: 94-149行目 (キャッシュ管理)

**影響**:
- 無駄なAPI呼び出し
- キャッシュ間の不整合
- パフォーマンスの不安定さ

### 3.9 食品量(quantity)の解析ロジックの冗長さと矛盾

**問題**: 食品量の文字列解析が複数の場所に実装され、一貫性がない

**該当ファイル**:
- `src/lib/nutrition/supabase-db.ts`: 609-693行目 (`parseQuantity` メソッド)
- `src/lib/nutrition/calculator.ts`: 64-109行目 (`parseQuantity` メソッド)

**影響**:
- 量の解釈が処理フローによって異なる可能性
- 重複コード
- バグ修正・機能拡張の困難さ

### 3.10 プロンプト設計と応答解析の連携不足

**問題**: プロンプトの設計と応答解析のロジックが緊密に連携していない

**該当ファイル**:
- `src/lib/ai/prompts/templates/food-analysis/v1.ts`: 全体
- `src/lib/ai/response-parser.ts`: 全体

**影響**:
- プロンプト変更時に応答解析ロジックの修正が必要
- 拡張性の低さ
- エラーの発生しやすさ

## 4. 推奨改善アプローチ

### 4.1 栄養計算の統一と抽象化

1. **栄養計算サービスの一元化**:
   - 単一のサービスクラスに栄養計算責任を集約
   - 一貫したインターフェースの提供
   - データソース（Supabase/ローカル）の抽象化

2. **確信度閾値の引き上げと段階的対応**:
   - 閾値を少なくとも0.5以上に引き上げ
   - 確信度に応じた視覚的フィードバック
   - 低確信度時の代替提案メカニズム

3. **食品マッチングの最適化**:
   - データベースでのエイリアス管理の一元化
   - 段階的マッチング戦略の明確化と簡素化
   - 食品名正規化ロジックの分離

### 4.2 型システムの整理

1. **栄養関連型の再設計**:
   - 基本型と拡張型の明確な階層構造
   - 型変換ユーティリティの集約
   - 一貫した命名規則の適用

2. **APIインターフェースの標準化**:
   - 一貫したリクエスト/レスポンス型の適用
   - エラー型の統一
   - 共通のバリデーションロジック

### 4.3 ユーザーエクスペリエンスの改善

1. **確信度フィードバックの強化**:
   - 低確信度のビジュアル表示（カラーコード、アイコン）
   - 段階的な警告と提案
   - ユーザー修正インターフェースの改善

2. **エラー処理とフォールバックの改善**:
   - 明示的なエラーメッセージ
   - ユーザーが取るべき行動の提案
   - グレースフルデグラデーション

## 5. 具体的な改善例

### 確信度閾値と表示の改善例:

```typescript
// src/lib/nutrition/food-matching-service.ts (新規作成)
export class FoodMatchingService {
  // 確信度レベルの定義
  static readonly CONFIDENCE_LEVELS = {
    HIGH: 0.85,    // 高確信度
    MEDIUM: 0.7,   // 中確信度
    LOW: 0.5,      // 低確信度
    MINIMUM: 0.35  // 最低確信度（これ以下は採用しない）
  };
  
  // 確信度に基づく表示スタイルの取得
  static getConfidenceStyle(confidence: number): {
    color: string;
    icon: string;
    message: string;
  } {
    if (confidence >= this.CONFIDENCE_LEVELS.HIGH) {
      return {
        color: 'text-green-600',
        icon: 'check-circle',
        message: '高確信度'
      };
    } else if (confidence >= this.CONFIDENCE_LEVELS.MEDIUM) {
      return {
        color: 'text-blue-600',
        icon: 'info',
        message: '中確信度'
      };
    } else {
      return {
        color: 'text-yellow-600',
        icon: 'alert-triangle',
        message: '低確信度 - 確認をお勧めします'
      };
    }
  }
  
  // 他のメソッド...
}
```
# 栄養素計算システムの再設計方針

システムが大きくなる前の再設計は非常に賢明な判断です。基本食品リストを活用した包括的な再設計の方針を以下に示します：

## 1. アーキテクチャ再設計の核心

- **単一責任の原則適用**: 各コンポーネントが明確に定義された単一の責任を持つように再構成
- **レイヤード設計**: データアクセス、ドメインロジック、プレゼンテーションの明確な分離
- **依存性逆転**: 具体的な実装への依存を抽象に置き換え

## 2. 核となるコンポーネント設計

- **NutritionService**: 栄養計算の単一責任インターフェース
- **FoodRepository**: 食品データアクセスの抽象インターフェース
  - `BasicFoodRepository`: 基本食品リスト実装
  - `SupabaseFoodRepository`: バックアップとしてのSupabase実装
- **ConfidenceManager**: 確信度評価と閾値管理の専用サービス

## 3. 型システムの統一

- **基本型の再設計**: 共通の基本型から派生する階層的構造
- **不変オブジェクト**: 変更不可能なデータ構造の採用
- **マッピング層**: 異なるシステム間のデータ変換を専門に扱う

## 4. 入力経路の統一

- **統一APIレイヤー**: 全ての入力経路（画像、テキスト、レシピ）で同一のサービスを使用
- **アダプターパターン**: AIレスポンスを標準形式に変換する専用アダプター

## 5. 体験改善の統合

- **確信度可視化**: 一貫した確信度表示と警告システム
- **インタラクティブ修正**: ユーザーによる低確信度データの容易な修正機能
- **フィードバックループ**: ユーザー修正を学習するメカニズム

## 6. 実装アプローチ

1. 新しいシステムを既存コードと並行して実装
2. 入力経路ごとに段階的に移行
3. 新旧システムの比較テストで精度を検証
4. 完全移行後に旧コードを除去

基本食品リストを中心に据えつつ、システム全体を柔軟で拡張性のある構造に再設計することで、現在の問題を根本から解決し、将来の機能追加も容易になります。